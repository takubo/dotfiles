*awk.txt*	For Vim version 7.3.  Last change: 2013 Feb 26


			AWK - help file


==============================================================================
1. Operators						*awk-operators*

(...)			グルーピング。
$			フィールド。
++ --			インクリメント、デクリメント。
^ **			べき乗。これらの演算子は右から左へ結合する
			(`**'演算子はPOSIXでは定義されていない)。
+ - !			単項のプラス、マイナスと論理"否定"。
* / %			乗算、除算、剰余。
+ -			加算、減算。
Concatenation		連接を指示するための特別なトークンはない。
			オペランドを単純に並べて記述すればよい。
< <= == != > >= >> |	関係演算子と、リダイレクション。
			これらは同じ優先順位である。
			`>'の様なキャラクタは、関係演算子としてもリダイレクションとしても使われる。
			この両者の区別は文脈によって決定される。
			print文やprintf文中の入出力リダイレクション演算子は、
			式ではなく文のレベルに属している。
			リダイレクションは他の演算子のオペランドとなる様な式を生成しない。
			その結果、リダイレクションをより優先順位の低い演算子のそばに
			括弧なしで記述するということは意味がなく、
			例えば `print foo > a ? b : c'はシンタックスエラーとなる。
			この文の正しい書き方は`print foo > (a ? b : c)'である。
~ !~			マッチする、マッチしない。
in			配列の要素
&&			論理的な"かつ"
||			論理的な"または"
?:			条件演算子。この演算子は右から左に結合する。
= += -= *= /= %= ^= **=	代入。これらの演算子は右から左に結合する
			(`**='演算子は POSIXでは定義されていない)。


==============================================================================
2. Built in Functions					*awk-functions*

2.1 Numeric Built-in Functions				*awk-numeric-functions*

以下のリストは、数値を扱うすべての組込み関数である。
省略可能な引数はブラケット("[" と "]")で囲まれている。

int(x)		この関数は整数への丸めを行う。丸めのときは0へ向かってとなる。
sqrt(x)		この関数はxの正の平方根を返す。
exp(x)		これは自然対数eのx乗を返すか、xが範囲外であればエラーをレポートする。
log(x)		xが正の場合にはxの自然対数を返し、そうでない場合にはエラーとなる。
sin(x)		xの正弦を返す(xの単位はラジアン)。
cos(x)		xの余弦を返す(xの単位はラジアン)。
atan2(y, x)	y / xのアークタンジェントを返す(単位はラジアン)。
rand()		乱数を返す。randの返す値は0から1の範囲の数であり、0と1は含まれない。
srand([x])	乱数を生成するための出発点、もしくは種の値としてxをセットする。
		引数xを省略した場合、乱数の種としてその時点の日時が使用される。
		srandの返す値は以前使われていた乱数の種である。

しばしば整数の乱数を必要とするだろうが、
次にn未満の非負の整数の乱数を返すユーザー定義関数を挙げる。 >
	function randint(n) {
		 return int(n * rand())
	}
この例での掛け算は0より大きく、n未満の実数を作り出す。
それを(int を使って)0からn - 1の間の整数にする。
次の例は先ほどのものと同じ様な、1からnの間の整数を返す関数を使っている。
このプログラムはレコード入力の度に新しい乱数を出力する。 >
	awk '
	# サイコロをシミュレートする関数
	function roll(n) { return 1 + int(rand() * n) }

	# 三つの六面体サイコロを振り、
	# その合計を出力する。
	{
		printf("%d points\n", roll(6)+roll(6)+roll(6))
	}'

2.2 String Manipulation Built-in Functions		*awk-string-functions*

このセクションにある関数は一つ以上の文字列を検索したり変更したりするものである。
省略可能な引数はブラケット("[" と "]")で囲まれている。

index(in, find)				文字列inの中で、文字列findが出てくる最初の場所を検索し、見つかった文字列が始まるinのキャラクタの位置を返す。
					もしfindが見つからなかったなら、indexは0を返す(awkでの文字列の添字は1から始まると言うことを思い出して欲しい)。
					例を挙げよう。 >
					$ awk 'BEGIN { print index("peanut", "an") }'
					-| 3
length([string])			string中のキャラクタの数を返す。引数が省略された場合、lengthは$0の長さを返す。
					古いバージョンのawkでは、length関数を括弧なしで呼ぶことができる。それは POSIXの標準では"deprecated"とされる。
match(string, regexp)			match関数はstringから、正規表現regexpにマッチする部分文字列の中で、最も左にあり、
					もっとも長い部分文字列を検索し、部分文字列が始まる場所を返す（stringの最初から始まっていれば1）。
					マッチするものが見つからなかった場合、0を返す。
					match関数は組み込み変数のRSTARTにインデックスをセットし、
					同様に組み込み変数RLENGTHにマッチした部分文字列の長さをセットする。
					マッチしなかった場合には、RSTARTには0が、RLENGTHには -1がセットされる。
split(string, array [, fieldsep])	この関数はstringをfieldsepによって分割し、分割された結果を arrayに格納する。
					分割された最初の要素はarray[1]に、二番目 の要素は array[2]に格納され、以下の要素も同様である。
					三番目の引数fieldsepの文字列値は、 stringを分割する場所を指定する
					（FSが入力レコードを分割する場所にマッチする正規表現であるように）正規表現である。
					fieldsepが省略されると、FSの値が使われる。 splitは作り出された要素の数を返す。
					split関数はまた、入力行をフィールドに分割するとの同じ様なやり方で文字列を分割する。
					入力フィールドを分割するときと同じ様に、fieldsepの値が" "である場合には先頭や末尾にある空白は無視され、要素は空白で区切られる。
					また同様に、fieldsepが空文字列であれば、個々のキャラクタが配列の要素となるように分割がおこなわれる(これはgawk特有の拡張である)。
					最近のgawk処理系では、gawkも含めて、この関数の第三引数に文 字列だけでなく(/abc/)のような正規表現定数を許している。
					(d.c.)POSIXの標準も同様である。
					文字列の分割に先立って、splitは配列arrayの要素をすべて削除する(d.c.)
					stringのどこにもfieldsepにマッチするものがない場合、arrayは一つの要素を持つようになる。その要素の値は、元々のstringと同じである。
sprintf(format, expression1,...)	この関数はprintfがその引数を渡されたときに出力するであろう文字列を(出力はせずに)返す。
sub(regexp, replacement [, target])	sub関数はtargetの値を変更する。
					検索する値は文字列でなければならず、そしてそれはregexpで与えられる正規表現にマッチする部分文字列の中で一番左にあり、
					長さが一番長いものである文字列全体の内マッチしたテキストはreplacementで置き換えられる。
					置き換えられた文字列はtargetの新しい値となる。
					この関数は独特である。それは、targetが単に値を計算するのに使われるのではなく、式ではないということからくる。
					targetは変数、フィールド、配列 の参照のように変更された値を格納できるものでなければならない。
					この引数が省略 された場合にはデフォルトとして$0が使用される。
					sub関数は置き換えを行った数(つまり1か0のいずれか)を返す。
					replacement中にスペシャルキャラクタ`&'があると、それはregexpにマッチした部分文字列を表す。
					(もしこの正規表現が二つ以上の文字列にマッチするのならば、`&'が表す部分文字列が変化するだろう)
					スペシャルキャラクタ(`&')の効果はその前にバックスラッシュを付けることによって抑制することができる。
					例によって、文字列中に一つのバックスラッシュを入れるためにはバックスラッシュを二つ続けて書かなければならない。
					従って、置換文字列中に`&'という文字を含ませるには`\\&'と記述する。
					次に挙げる例は 各行で最初に現れる`|'を`&'で置き換える。
					awk '{ sub(/\|/, "\\&"); print }'
					Note 上述のように、subの三番目の引数は左辺値でなければならない。
					一部のawk処理系には三番目の引数として左辺値でない式を許すものもある。
					そういった場合、subはパターンを検索し、0か1を返すけれども、置き換え(起 こったとして)の結果は、
					それを格納する場所がないので失われる。
					過去のものに対する互換性のために、gawkはこのような間違ったコード を受容する。
					しかしながら、第三引数として別の変更不能なオブジェクトを使った場合には致命的エラーを引き起こす結果となり、
					プログラムを実行することができないだろう。
					結局のところ、regexpは正規表現定数ではなく、文字列へと変換されその文字列値がマッチすべき正規表現として取り扱われるものである。
gsub(regexp, replacement [, target])	この関数はsubと似ているが、gsubはもっとも長く、最も左にあり、それぞれが重ならないようなマッチした部分文字列をすべて置換する。
					gsubの`g'は全ての場所で置換を行う"global"を意味する。
					gsub関数は置き換えが起こった回数を返す。
					検索と置換の対象となる変数targetが省略された場合、入力レコード全体、つまり$0が使用される。
					subと同じ様に、`&' と `\'の二つのキャラクタは特殊な意味があり、また三番目の引数は左辺値でなければならない。
gensub(regexp, replacement, how [, target])
					gensubは汎用的な置換関数である。
					subやgsubのように対象文字列targetから正規表現regexpにマッチする部分を検索する。
					subやgsubと違うのは、関数の戻り値として置換が行われた文字列を返し、元の文字列を変更しないという点である。
					もしhowが`g'か`G'で始まる文字列であれば、regexpにマッチする全てのものをreplacementに置き換え、
					そうでない場合にはhowは何番目にマッチしたものをregexpで置き換えるかを指示する。
					targetが渡されなかった場合、$0が代わりに使われる。
					gensubには、置換テキストの中で正規表現の構成要素を指定するというsubやgsubにはない機能が追加されている。
					これはマークする正規表現を括弧で囲み、置換テキストの中で`\n'を使って指定する。nは1から9までの数字である。
					置換テキスト中では、`\0'は`&'と同じようにマッチしたテキスト全体を表わす。
					次の例は、三番目の引数を置き換えの対象となる(正規表現にマッチした)テキストを指定するためにどのように使うかを表わしている。 >
						$ echo a b c a b c |
						> gawk '{ print gensub(/a/, "AA", 2) }'
						-| a b c AA b c
					この場合、$0がデフォルトの(置き換えの)対象文字列として使用される。
					もし引数howが`g'でも`G'でも始まっていない文字列や、0よりも小さい数値であったとすると、一度だけ置換が行われる。
					regexpがtargetにマッチしなかった場合、gensubの戻り値は元の値であり、targetを変更することはない。
					gensubはgawkの拡張であり、互換モード(セクションコマンドラインオプションを参照)では使用できない。
substr(string, start [, length])	この関数はstring中でstart番目のキャラクタから始まる長さlengthの部分文字列を返す。
					文字列の最初のキャラクタの数は1である。
					lengthが与えられない場合、この関数はstringでstart番目から始まる残りの部分全てを返す。
					lengthがstart番目から文字列の終端までの長さよりも長い場合も同様である。
tolower(string)				この関数は与えられたstring中の大文字を小文字に置き換えた文字列を返す。
toupper(string)				この関数は与えられたstring中の小文字を大文字に置き換えた文字列を返す。











int(x)
この関数は整数への丸めを行う。 丸めのときは0へ向かって、つまり0とxの間にある整数の中から選択する。 例えば、int(3) は 3、 int(3.9) は 3、 int(-3.9) は -3、そして int(-3) は -3 となる。
sqrt(x)
この関数はxの正の平方根を返す。 xが負であった場合にはエラーとな る。たとえば、sqrt(4)は2である。
exp(x)
これは自然対数eのx乗を返すか、xが範囲外であればエラーをレポート する。 xの取り得る値の範囲はあなたが使っているマシンの浮動小数点数の実 装による。
log(x)
xが正の場合にはxの自然対数を返し、そうでない場合にはエラーとなる。l
sin(x)
xの正弦を返す(xの単位はラジアン)。
cos(x)
xの余弦を返す(xの単位はラジアン)。
atan2(y, x)
y / xのアークタンジェントを返す(単位はラジアン)。
rand()
乱数を返す。randの返す値は0から1の範囲の数であり、0と1は含まれない。 しばしば整数の乱数を必要とするだろうが、次に n未満の非負の整数の乱数を 返すユーザー定義関数を挙げる。
function randint(n) {
     return int(n * rand())
}
この例での掛け算は0より大きく、n未満の実数を作り出す。それを(int を使って)0からn - 1の間の整数にする。 次の例は先ほどのものと同じ様な、1からnの間の整数を返す関数を使っている。 このプログラムはレコード入力の度に新しい乱数を出力する。
awk '
# サイコロをシミュレートする関数
function roll(n) { return 1 + int(rand() * n) }

# 三つの六面体サイコロを振り、
# その合計を出力する。
{
      printf("%d points\n",
             roll(6)+roll(6)+roll(6))
}'
注意:gawkも含めて、大部分のawk処理系では実行の度 にrandは、同じ数値、もしくは種から数値を作り出しはじめる。 このことはプログラムを実行する度に同じ結果が生成されるということである。 その数値はひとつのawkプログラムの中ではランダムであるけれども走ら せるごとに予想できるものである。これはデバッグには便利であるけれども、使 う度毎に違う結果を必要とするような場合には実行する毎に乱数の種を違ったも のにしなければならない。それを行うにはsrandを使用する。
srand([x])
srandは乱数を生成するための出発点、もしくは種の値として xをセットする。 それぞれの種は各々特定の"乱数列" (11) を導き出す。従って、乱数の種として同じ値を 二度目にセットしたとすると、同じ"乱数列"を得ることになる。 srand()の引数xを省略した場合、乱数の種としてその時点の日時が使 用される。この方法は予測できないような乱数列を得られる。 srandの返す値は以前使われていた乱数の種である。これによって以前の乱数 系列をもう一度作り出すことが簡単になる。





index(in, find)
文字列inの中で、文字列findが出てくる最初の場所を検索し、 見つかった文字列が始まるinのキャラクタの位置を返す。例を挙げよう。
$ awk 'BEGIN { print index("peanut", "an") }'
-| 3
もしfindが見つからなかったなら、indexは0を返す (awkでの文字列の添字は1から始まると言うことを思い出して欲しい)。
length([string])
string中のキャラクタの数を返す。 stringが数値であった場合、その 数値を（その数値を表す）文字列に変換したときのキャラクタの数が返る。例えば、 length("abcde")は5であるが、length(15 * 35)の結果は 3である。 それは15 × 35 = 525で、この525は三つのキャラクタからなる `"525"'という 文字列に変換されるからである。 引数が省略された場合、lengthは$0の長さを返す。 古いバージョンのawkでは、length関数を括弧なしで呼ぶことができ る。それは POSIX の標準では"deprecated"とされる。このことは、プログラム中 でこういった書き方が将来のバージョンでは使えなくなるかも知れないということで ある。従って、awkプログラムの移植性を最大にするために括弧を常に書くべ きである。
match(string, regexp)
match関数はstringから、正規表現regexpにマッチする部分文字 列の中で、最も左にあり、もっとも長い部分文字列を検索し、部分文字列が始まる場 所を返す（stringの最初から始まっていれば1）。マッチするものが見つから なかった場合、0を返す。 match関数は組み込み変数のRSTART にインデックスをセットし、同様 に組み込み変数RLENGTHにマッチした部分文字列の長さをセットする。マッチ しなかった場合には、RSTART には0が、RLENGTH には -1がセッ トされる。 例えば、
awk '{
       if ($1 == "FIND")
         regex = $2
       else {
         where = match($0, regex)
         if (where != 0)
           print "Match of", regex, "found at", \
                     where, "in", $0
       }
}'
このプログラムは変数regexに格納されている正規表現にマッチする行を探す。 この正規表現は変更することができる。ある行の最初の単語が`FIND'であった 場合、 regexはその行の二番目の単語に変更される。従って、次のようなデー タを与えると
FIND ru+n
My program runs
but not very quickly
FIND Melvin
JF+KM
This line is property of Reality Engineering Co.
Melvin was here.
awkの出力は次のようになる。
Match of ru+n found at 12 in My program runs
Match of Melvin found at 1 in Melvin was here.
split(string, array [, fieldsep])
この関数はstringをfieldsepによって分割し、分割された結果を arrayに格納する。分割された最初の要素はarray[1]に、二番目 の要素は array[2]に格納され、以下の要素も同様である。三番目の引 数fieldsepの文字列値は、 stringを分割する場所を指定する （FSが入力レコードを分割する場所にマッチする正規表現であるように）正 規表現である。 fieldsepが省略されると、FSの値が使われる。 splitは作り出された要素の数を返す。 split関数はまた、入力行をフィールドに分割するとの同じ様なやり方で文字 列を分割する。例えば、
split("cul-de-sac", a, "-")
これは`-'をセパレータとして、`auto-da-fe'という文字列を三つのフィ ールドに分割し、配列aの要素を以下のようにセットする。
a[1] = "cul"
a[2] = "de"
a[3] = "sac"
splitを呼び出して返ってくる値は3である。 入力フィールドを分割するときと同じ様に、fieldsepの値が" " であ る場合には先頭や末尾にある空白は無視され、要素は空白で区切られる。 また同様に、fieldsepが空文字列であれば、個々のキャラクタが配列の要 素となるように分割がおこなわれる(これはgawk特有の拡張である)。 最近のgawk処理系では、gawkも含めて、この関数の第三引数に文 字列だけでなく(/abc/)のような正規表現定数を許している。(d.c.) POSIXの標準も同様である。 文字列の分割に先立って、splitは配列arrayの 要素をすべて削除する(d.c.) stringのどこにもfieldsepにマッチするものがない場合、 arrayは一つの要素を持つようになる。その要素の値は、 元々のstringと同じである。
sprintf(format, expression1,...)
この関数はprintfがその引数を渡されたときに出力するであろう文字列を (出力はせずに)返す。 (セクション Using printf Statements for Fancier Printingを参照). 例えば、
sprintf("pi = %.2f (approx.)", 22/7)
returns the string "pi = 3.14 (approx.)". これは"pi = 3.14 (approx.)"という文字列を返す。
sub(regexp, replacement [, target])
sub関数はtargetの値を変更する。検索する値は文字列でなければなら ず、そしてそれは regexpで与えられる正規表現にマッチする部分文字列の中 で一番左にあり、長さが一番長いものである文字列全体の内マッチしたテキストは replacementで置き換えられる。 置き換えられた文字列はtargetの新しい値となる。 この関数は独特である。それは、targetが単に値を計算するのに使われるので はなく、式ではないということからくる。 targetは変数、フィールド、配列 の参照のように変更された値を格納できるものでなければならない。この引数が省略 された場合にはデフォルトとして$0が使用される。 例を挙げよう。
str = "water, water, everywhere"
sub(/at/, "ith", str)
この例では strに"wither, water, everywhere"をセットし、その 中で最も左にあり、もっとも長い`at'を`ith'に置き換える。 sub関数は置き換えを行った数(つまり1か0のいずれか)を返す。 replacement中にスペシャルキャラクタ`&'があると、それはregexp にマッチした部分文字列を表す。 (もしこの正規表現が二つ以上の文字列にマッチす るのならば、 `&'が表す部分文字列が変化するだろう) 例えば、
awk '{ sub(/candidate/, "& and his wife"); print }'
これは各入力行で最初に現れる`candidate'を`candidate and his wife'に 変更する。 別の例を挙げよう。
awk 'BEGIN {
        str = "daabaaa"
        sub(/a*/, "c&c", str)
        print str
}'
-| dcaacbaaa
この例では`dcaacbaaa'が出力される。これは`&'は非文字定数として扱わ れ、"最左最長"の規則に従っている為である。 (セクション How Much Text Matches?を参照)。 スペシャルキャラクタ(`&')の効果はその前にバックスラッシュを付けることに よって抑制することができる。例によって、文字列中に一つのバックスラッシュを入 れるためにはバックスラッシュを二つ続けて書かなければならない。従って、置換文 字列中に`&'という文字を含ませるには`\\&'と記述する。次に挙げる例は 各行で最初に現れる`|'を`&'で置き換える。
awk '{ sub(/\|/, "\\&"); print }'
ノート:上述のように、subの三番目の引数は左辺値でなければならな い。一部のawk処理系には三番目の引数として左辺値でない式を許すものもある。 そういった場合、subはパターンを検索し、0か1を返すけれども、置き換え(起 こったとして)の結果は、それを格納する場所がないので失われる。そのような awkは次のような式を受け付ける。
sub(/USA/, "United States", "the USA and Canada")
過去のものに対する互換性のために、gawkはこのような間違ったコード を受容する。しかしながら、第三引数として別の変更不能なオブジェクトを 使った場合には致命的エラーを引き起こす結果となり、プログラムを実行する ことができないだろう。 結局のところ、regexpは正規表現定数ではなく、文字列へと変換され その文字列値がマッチすべき正規表現として取り扱われるものである。
gsub(regexp, replacement [, target])
この関数はsubと似ているが、gsubはもっとも長く、最も左にあり、 それぞれが重ならないようなマッチした部分文字列をすべて置換する。 gsubの`g'は全ての場所で置換を行う"global"を意味する。次の例で は、
awk '{ gsub(/Britain/, "United Kingdom"); print }'
全ての入力レコードで、`Britain'という文字列を全て `United Kingdom' に置き換える。 gsub関数は置き換えが起こった回数を返す。検索と置換の対象となる変数 targetが省略された場合、入力レコード全体、つまり$0が使用される。 subと同じ様に、`&' と `\'の二つのキャラクタは特殊な意味があ り、また三番目の引数は左辺値でなければならない。
gensub(regexp, replacement, how [, target])
gensubは汎用的な置換関数である。subやgsubのように 対象文字列targetから正規表現regexpに マッチする部分を検索する。subやgsubと違うのは、 関数の戻り値として置換が行われた文字列を返し、 元の文字列を変更しないという点である。 もしhowが`g'か`G'で始まる文字列であれば、 regexpにマッチする全てのものをreplacementに置き換え、 そうでない場合には howは何番目にマッチしたものを regexpで置き換える かを指示する。 targetが渡されなかった場合、$0が代わりに 使われる。 gensubには、 置換テキストの中で正規表現の構成要素を指定する というsubやgsubにはない機能 が追加されている。 これはマークする正規表現を括弧で囲み、置換テキスト の中で`\n'を使って指定する。 nは1から9までの数字である。 例えば、
$ gawk '
> BEGIN {
>      a = "abc def"
>      b = gensub(/(.+) (.+)/, "\\2 \\1", "g", a)
>      print b
> }'
-| def abc
subで説明したように、文字列中でバックスラッシュを一つ 置くためには、二つタイプしなければならない。 置換テキスト中では、`\0'は`&'と同じように マッチしたテキスト全体を表わす。 次の例は、三番目の引数を置き換えの対象となる (正規表現にマッチした)テキストを指定するために どのように使うかを表わしている。
$ echo a b c a b c |
> gawk '{ print gensub(/a/, "AA", 2) }'
-| a b c AA b c
この場合、$0がデフォルトの(置き換えの)対象文字列として 使用される。gensubは置き換えを行った結果の新しい 文字列を戻り値として返し、それは直接printで出力する ものとして(printに)渡される。 もし引数howが`g'でも`G'でも始まっていない 文字列や、0よりも小さい数値であったとすると、 一度だけ置換が行われる。 regexpがtargetにマッチしなかった場合、gensubの 戻り値は元の値であり、targetを変更することはない。 gensubはgawkの拡張であり、 互換モード(セクション コマンドラインオプションを参照)では 使用できない。
substr(string, start [, length])
この関数はstring中でstart番目のキャラクタから始まる長さ lengthの部分文字列を返す。文字列の最初のキャラクタの数は1である。例え ば、substr("washington", 5, 3)は"ing"を返す。 lengthが与えられない場合、この関数はstringで start番目から 始まる残りの部分全てを返す。例えば、substr("washington", 5)は "ington"を返す。 lengthがstart番目から文字列の終端までの 長さよりも長い場合も同様である。 注意:substrが返す文字列に代入することはできない。 したがって、以下に示す例のようにして文字列の一部を変更しようとすることは 間違いである。
string = "abcdef"
# "abCDEf"を得ようとしているが、うまく行かない
substr(string, 3, 3) = "CDE"
また、subやgsubの第三引数としてsubstrを使うのも 間違いである。
gsub(/xyz/, "pdq", substr($0, 5, 20))  # 間違い
tolower(string)
この関数は与えられたstring中の大文字を小文字に置き換えた文字列を返す。 このときアルファベット以外のキャラクタは変更されない。例えば、 tolower("MiXeD cAsE 123") は "mixed case 123"を返す。
toupper(string)
この関数は与えられたstring中の小文字を大文字に置き換えた文字列を返す。 このときアルファベット以外のキャラクタは変更されない。例えば、 toupper("MiXeD cAsE 123") は "MIXED CASE 123"を返す。



 vim:tw=78:ts=8:ft=help:norl:
